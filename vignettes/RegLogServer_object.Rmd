---
title: "RegLogServer object fields and methods"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RegLogServer object fields and methods}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## About R6 and specifically RegLogServer Class

*R6* is the alternative class system available for **R** users. It is more driven towards
Object Oriented Programming vs Functional Programming that is most known to **R** users
via built-in *S3* class system.

*R6* is ideal for creating more complex systems - it keeps all their elements enclosed
in their own environment. Most of **R** users actually uses *R6* objects on
daily basis: eg. the whole *Shiny* system is built as system of *R6* objects.

Basically, all there is to know about *R6* system in regards to *shiny.reglog*
usage is, that:

- all modules available in *shiny.reglog* are *R6* classes:
  - *RegLogServer*
  - dbConnectors - which are used by every *RegLogServer* to communicate with
  database containing your user data.
     - *RegLogDBIConnector*
     - *RegLogGsheetConnector*
  - mailConnectors - which are used by every *RegLogServer* to send emails to
  users of your ShinyApp.
     - *RegLogEmayiliConnector*
     - *RegLogGmailConnector*
  - vanilla *RegLogConnector*, that you can use to create your own *Connector*.
- R6 objects after initialization have public elements, that can be accessed
  with `$`. They can be either *fields*, holding some values, or *methods*
  containing functions.
  
If you want to get to know more about R6 system as a whole I advise you to check
out [articles created by R6 maintainers](https://r6.r-lib.org/articles/). Below
I will talk more thoroughly about *RegLogServer* class and its public fields and
methods.

There are multiple public elements to *RegLogServer*. To keep them in order, I will
describe them on basis of their usage. In all code chunks I will refer to them
as if they would be called from an object assigned as *RegLogServer*:

```{r setup, include=F}
library(shiny.reglog)
```

```{r RegLogServer_assignement_example, eval = F}
  RegLogServer <- RegLogServer$new(
    dbConnector = dbConnector,
    mailConnector = mailConnector)
```

## State of user in current ShinyApp session

Elements described there are the most important things that every creator of 
ShinyApp that incorporates *shiny.reglog* should be using to profit from user
login. All of them are `reactiveVal` objects, so you can `observe` their changes
and to access their current value you need to include them with parentheses.

### Check if the user in current session is logged in

`is_logged` is a simple boolean value to check if the user in current session is 
logged in (`TRUE`) or not (`FALSE`)

```{r is_logged, eval = F}
# observe the reactiveVal change
observeEvent(RegLogServer$is_logged, {
  
  # if contains TRUE: user is currently logged-in
  if (RegLogServer$is_logged()) {
    showModal(modalDialog(title = "You are logged in!"))
    # if contains FALSE: user isn't logged-in
  } else {
    showModal(modalDialog(title = "You are not logged in!"))
  }
})
```

### Current ID of the user

`user_id` field (character string): unique user ID. When the user 
isn't logged it contains generated at the start of the session (or after logout)
*Universally Unique Identifier* (with the use of `uuid::UUIDgenerate()`).
```{r uuid_example}
uuid::UUIDgenerate()
```
After login it contains the username that the user have chosen during registration
procedure.
```{r user_id, eval = F}
RegLogServer$user_id()
```

### Email address of the currently logged user

`user_mail` field (character string): unique user email. When the user is logged in,
it contains the email that is currently associated with their *user_id*. Otherwise,
it contains empty character string (`""`).
```{r user_mail, eval = F}
RegLogServer$user_mail()
```

## UI object lists

There are dedicated functions for creating UI for different functionalities of the
*RegLog* system: `RegLog_login_UI`, `RegLog_register_UI`, `RegLog_credsEdit_UI`
and `RegLog_resetPass_UI`. They put whole default `tagLists` into the UI, though.

It is expected that there will be users who would want more freedom with how
their UI should look like. That's why there are dedicated public fields containing
named lists of UI elements for all of these functionalities. You can use these
to create your own, custom `renderUI` output.

## Message

`message` field is another `reactiveVal` value that can be used to observe
**any** change of the *RegLogServer* object state. It always contains most recent object 
of *S3* class **RegLogConnectorMessage**, that the *RegLogServer* received from its
*dbConnector* or *mailConnector*, or was specifically generated to communicate
specific status changes.

Creation of custom logic depending on its change isn't at all necessary. It can
be handy especially when for any reason you want to inhibit the default
*modalDialog*s that are called by *RegLogServer* to inform end-user about
consequences of their actions (eg. successful login or unsuccessful, because the
inputed user ID or password is incorrect). 

Every *RegLogConnectorMessage* is specific type of *list* and can contain up to 
four elements:

- **time**: numeric representation of `Sys.time()` when it was generated
- **type**: indicates the type of the process during which the message was generated
- **data**: *list* containing data that was send with this message. Values
contained there can be specific to certain *type* of the message
- **logcontent**: all *RegLogConnectorMessage*s send by and received by the
*RegLogServer* object (and by every *RegLogConnector*) are appended to that
object `log` field. Content there will be saved as a *note* in the logs.

Below I want to characterize all types of *RegLogConnectorMessages* that can be
exposed in the `RegLogServer$message()` field. Besides them there are also messages
that are send by the *RegLogServer* to its *Connectors*. To learn more about these,
read vignette **Creating custom RegLogConnector handlers**.

>Conditions for every default modalDialog are written in the order they should be
checked in for best results. 
>Conditions written like `value == FALSE` can be checked like that - the *message*
of given type always contains this object. Conditions written like `isFALSE(value)` 
means that the *value* in the *message* can be `NULL`.

### Type: **ping**

Type of the message that is produced by all classes inheriting from *RegLogConnector*
upon their initialization, making it also the very first available in `RegLogServer$message()`
field. Received message of this type contains:

- *data*: response_time: time between receiving the **ping** message and sending
this message back
- *logcontent*: for message upon initialization it will hold value "init".

### Type: **login_front**

Type of the message generated by *RegLogServer* object itself. Contains
information about invalidity of values provided during login procedure
by user. It contains:

- **data**
  - success: boolean - `FALSE`
  - input_provided: boolean - `FALSE`
  
This message type is binded with default *modalDialogs*:

- login_noInput (`input_provided == FALSE`)

### Type: **login**

Type of the message received from the database connectors with responses about
login procedure. It contains:

- **data**:
  - success: boolean - `TRUE` if the login was successful
  - username: boolean - `TRUE` if the username exists in the database
  - password: boolean - `TRUE` if the password provided match
  - *user_id*: character - contains user_id presented afterwards in the
  `RegLogServer$user_id()`. Only if `success == TRUE`
  - *user_mail*: character - contains user_mail presented afterwards in the
  `RegLogServer$user_mail()`. Only if `success == TRUE`
- **logcontent**:
  - brief information with username provided by the user and if the login
  was successful.

This message type is binded with default *modalDialogs*:

- login_badId (`data$success == FALSE && data$username == FALSE`)
- login_badPass (`data$success == FALSE && data$password == FALSE`)
- login_success (`data$success == TRUE`)


### Type: **register_front**

Type of the message generated by *RegLogServer* object itself. Contains
information about invalidity of values provided during register procedure
by user. It contains:

- **data**:
  - success: boolean - `FALSE`
  - valid_id: boolean - `TRUE` if provided user ID was valid
  - valid_email: boolean - `TRUE` if provided email was valid
  - valid_pass: boolean - `TRUE` if provided password was valid
  - identical_pass: boolean - `FALSE` (it is the last condition checked)
  
This message type is binded with default *modalDialogs*:

- register_noInput (`data$input_provided == FALSE`)
- register_nonValidID (`isFALSE(data$valid_id)`)
- register_nonValidEmail (`isFALSE(data$valid_email)`)
- register_nonValidPass (`isFALSE(data$valid_pass)`)
- register_notIndenticalPass (`isFALSE(data$identical_pass)`)

### Type: **register**

Type of the message received from the database connector with responses about
register procedure. It contains:

- **data**:
  - success: boolean - `TRUE` if the register was successful
  - username: boolean - `TRUE` if there were no conflicts with existing 
  usernames in the database
  - email: boolean - `TRUE` if there were no conflicts with existing
  e-mails in the database
  - *user_id*: character - contains user ID with which new user have been
  registered. Only if `success == TRUE`
  - *user_mail*: character - contains e-mail with which new user have
  been registered. Only if `success == TRUE`
- **logcontent**:
  - registered user ID and mail if the register was successful or value
  of the element which caused conflict.
  
This message type is binded with default *modalDialogs*:

- register_existingID (`data$success == FALSE && data$username == FALSE`)
- register_existingMail (`data$success == FALSE && data$email == FALSE`)
- register_success (`data$success == TRUE`)

### Type: **register_mail**

Type of the message received from mailConnector with response about confirmation
mail send. It contains:

- **data**
  - success: boolean - `TRUE` if the register mail send was successful
- **logcontent**
  - registered username and email to which the mail was send. If there were any
  error during sending, it will be also appended.

### Type: **credsEdit_front**

Type of the message generated by *RegLogServer* object itself. Contains
information about invalidity of values provided during credentials change procedure
by user. It contains:

- **data**:
  - success: boolean - `FALSE` (generated only when something is invalid)
  - input_provided: boolean - `TRUE` if required inputs are not empty
  - valid_id: boolean - `TRUE` if provided user ID was valid
  - valid_email: boolean - `TRUE` if provided email was valid
  - valid_pass: boolean - `TRUE` if provided password was valid
  - identical_pass: boolean - `FALSE` (it is the last condition checked)
  
This message type is binded with default *modalDialogs*:

- credsEdit_noInput_pass (`data$input_provided == FALSE` && change == "pass"`)
- credsEdit_noInput_other (`data$input_provided == FALSE` && change == "other"`)
- credsEdit_badId (`isFALSE(data$username)`)
- credsEdit_badPass (`isFALSE(data$password)`)
- credsEdit_existingID (`isFALSE(data$username)`)
- credsEdit_existingMail (`isFALSE(data$email)`)

### Type: **credsEdit**

Type of the message received from the database connector with responses about
credentials edit procedure. It contains:

- **data**:
  - success: boolean - `TRUE` if credentials edit was successful
  - username: boolean - `TRUE` if provided username was found
  - password: boolean - `TRUE` if provided password was correct
  - *new_username*: boolean - `TRUE` if provided new ID weren't in
  database (no conflicts). Only if there were some conflict.
  - *new_mail*: boolean - `TRUE` if provided new e-mail weren't in
  database (no conflicts). Only if there were some conflict.
  - *new_user_id*: character - contains new user ID. Only if user ID was changed.
  - *new_user_mail*: character - contains new user e-mail. Only if user mail
  was changed.
  - *new_user_pass*: boolean - `TRUE`. Only if user password was changed.
- **logcontent**:
  - brief information about changes.
  
This message type is binded with default *modalDialogs*:

- credsEdit_badId (`data$success == FALSE && data$username == FALSE`)
- credsEdit_badPass (`data$success == FALSE && data$password == FALSE`)
- credsEdit_existingID (`data$success == FALSE && isFALSE(data$username)`)
- credsEdit_existingMail (`data$success == FALSE && isFALSE(data$email)`)
- credsEdit_success (`data$success == TRUE`)

### Type: **resetPass_front**

Type of the message generated by *RegLogServer* object itself. Contains
information about invalidity of values provided during password reset procedure
by user. It contains:

- **data**
  - success: boolean - `FALSE` (message generated only when something is invalid)
  - valid_pass: boolean - `TRUE` if provided password was valid
  - identical_pass: boolean - `FALSE` (it is the last condition checked)
  
### Type:  **resetPass_generate**

Type of the message received from the database connector with responses about
password reset procedure - code generation step. It contains:

- **data**:
  - success: boolean - `TRUE` if reset code was created successfully
  - username: boolean - `TRUE` if the username was found in the database
  - email: character - email to which the reset code will be sent
- **logcontent**:
  - information about user for whom the reset code was generated and to which
  email it will be sent.
  
### Type: **resetPass_mail**

Type of the message received from mailConnectors with response about reset code
mail send. It contains:

- **data**
  - success: boolean - `TRUE` if the reset code mail send was successful
- **logcontent**
  - registered username and email to which the mail was send. If there was any
  error during sending, it will be also appended.
  
### Type: **resetPass_confirm** 

Type of the message received from the database connector with responses about
password reset procedure - code confirmation step. It contains:

- **data**
  - success: boolean - `TRUE` if the password was changed successfully
  - username: boolean - `TRUE` if the username was found in the database
  - code_valid: boolean - `TRUE` if the reset code was valid (both matched and not expired)
- **logcontent**
  - username for which the password was changed.